//This program is used to calculate the P(i) or ai, the repeat types of kmer freq in genomic sequence.
//This function can be modified easily to calcualte the heterozyous rate of diploid genome.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <inttypes.h>
#include<zlib.h>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include "gzstream.h"

using namespace std;

typedef long double qfloat;

int Rfreq_range = 100;
int Lowfreq_cutoff = 3;  //used to filter Kmers caused by sequencing errors
int Gfreq_range = 10;
double Mean_depth = 20;
int Max_depth = 0;
vector<qfloat> JCvec;
map<uint64_t,qfloat> KdepRate;
map<uint64_t,qfloat>::iterator Kiter;
qfloat pai = 3.1415926536;
qfloat Total_kmer_species = 0;
qfloat Total_diff_cutoff = 0.0001;
int Consider_heterozygosity = 0;

void usage() 
{	cout << "estimate_repeat <reads_kmerfreq_file>" << endl;
	cout << "   -r <int>  set the reads kmer freq range, default=" << Rfreq_range << endl;
	cout << "   -l <int>  set the cutoff of low freq kmers, default=" << Lowfreq_cutoff << endl;
	cout << "   -g <int>  set the genomic kmer freq range, default=" << Gfreq_range << endl;
	cout << "   -m <float>  set the mean depth , default=" << Mean_depth << endl;
	cout << "   -d <float>  set the total difference cutoff, default=" << Total_diff_cutoff << endl;
	cout << "   -z <int>  whether consider heterozygosity, default=" << Consider_heterozygosity << endl;
	cout << "   -h        get help information" << endl;
	cout << "\n\nNote:\nThe sum of ai or P(i) is not required to be 1, can be any value\n" << endl;
	exit(0);
}

qfloat jiecheng (int range)
{
	qfloat jc = 1.0;
	for (int i=1; i<=range; i++) {
			jc *= (qfloat)i;
	}
	return jc;
}

void calculate_posterior_pi(int ai_num, qfloat *p_i, qfloat *new_p_i)
{
	//calculate the prior probability of P(i|k)
	qfloat *p_k = new qfloat[Max_depth];
	qfloat *p_i_k = new qfloat[Max_depth*ai_num];
	for (int k=0; k<Max_depth; k++)
	{	p_k[k] = 0.0;
		for (int i=0; i<ai_num; i++)
		{	
			qfloat c = (!Consider_heterozygosity) ? (i+1)*Mean_depth : (float(i+1)/2)*Mean_depth;
			p_k[k] += p_i[i] * pow(c,k+1) / exp(c) / JCvec[k+1];
		}
		
		for (int i=0; i<ai_num; i++)
		{	
			qfloat c = (!Consider_heterozygosity) ? (i+1)*Mean_depth : (float(i+1)/2)*Mean_depth;
			p_i_k[k*ai_num+i] = p_i[i] * pow(c,k+1) / exp(c) / JCvec[k+1] / p_k[k];
		}
		//cout << k+1 << "\t" << p_k[k] << endl;
	}

	//calcalte the final result
	for (int i=0; i<ai_num; i++)
	{	new_p_i[i] = 0.0;
	}
	for (Kiter=KdepRate.begin(); Kiter!=KdepRate.end(); Kiter++)
	{	int n_k = Kiter->first - 1;
		qfloat p_n_k = Kiter->second;
		for (int i=0; i<ai_num; i++)
		{	
			new_p_i[i] += p_n_k * p_i_k[n_k*ai_num+i];
		}
	}
	
}


int main(int argc, char *argv[])
{	
	//get options from command line
	int c;
	while((c=getopt(argc, argv, "r:l:g:m:d:z:h")) !=-1) {
		switch(c) {
			case 'r': Rfreq_range=atoi(optarg); break;
			case 'l': Lowfreq_cutoff=atoi(optarg); break;
			case 'g': Gfreq_range=atoi(optarg); break;
			case 'm': Mean_depth=atof(optarg); break;
			case 'd': Total_diff_cutoff=atof(optarg); break;
			case 'z': Consider_heterozygosity=atoi(optarg); break;
			case 'h': usage(); break;
			default: usage();
		}
	}
	if (argc < 2) usage();
	
	string reads_kmerfreq_file = argv[optind++]; //optind, argv[optind++]顺序指向非option的参数
	string genomic_frequency_distribution_file = reads_kmerfreq_file + ".gfd";
	string coverage_depth_distribution_file = reads_kmerfreq_file + ".cdd";

	clock_t time_start, time_end;
	time_start = clock();
	
	for (int i=0; i<=Rfreq_range; i++)
	{	JCvec.push_back(jiecheng(i));
		//cerr << i << "\t" << jiecheng(i) << endl;
	}

	time_end = clock();
	cerr << "\nCalculate jiecheng done\n";
	cerr << "Run time: " << double(time_end - time_start) / CLOCKS_PER_SEC << endl;
	
	
	//parse the kmer freq stat file generated by kmerfreq
	igzstream infile;
	infile.open(reads_kmerfreq_file.c_str());
	if ( ! infile )
	{	cerr << "fail to open input file" << reads_kmerfreq_file << endl;
	}
	string lineStr;
	while (getline( infile, lineStr, '\n' ))
	{	if (lineStr[0] == '#' || lineStr[0] == '\n' || lineStr[0] == ' ' || lineStr[0] == '\t' || lineStr[0] == '>' || lineStr.size() == 0)
		{	continue;
		}
		vector<string> lineVec;
		boost::split(lineVec,lineStr, boost::is_any_of(" \t"), boost::token_compress_on);
		uint64_t Kdepth = boost::lexical_cast<uint64_t>(lineVec[0]); 
		qfloat Krate = boost::lexical_cast<qfloat>(lineVec[1]); 
		
		if (Krate > 0 && Kdepth <= Rfreq_range && Kdepth > Lowfreq_cutoff)
		{	KdepRate[Kdepth] = Krate;
			Total_kmer_species += Krate; //in fact here Krate stores Knumber
			if (Kdepth > Max_depth)
			{	Max_depth = Kdepth;
			}
			
		}
	}

	//converte number into rate
	for (Kiter=KdepRate.begin(); Kiter!=KdepRate.end(); Kiter++)
	{	
		Kiter->second = Kiter->second / Total_kmer_species;
	}
	cerr << "Max_depth: " << Max_depth << endl;
	
	time_end = clock();
	cerr << "\nParse the reads kmer freq file done\n";
	cerr << "Run time: " << double(time_end - time_start) / CLOCKS_PER_SEC << endl;

	int ai_num = (!Consider_heterozygosity) ? Gfreq_range : Gfreq_range*2;
	qfloat *p_i = new qfloat[ai_num];
	qfloat *new_p_i = new qfloat[ai_num]; //mean new p_i 
	for (int i=0; i<ai_num; i++)
	{	p_i[i] = 1 / (double)ai_num;  //assign equal probabilites at first
		//cerr << "ai:\t" << i << "\t "<< p_i[i] << endl;
	}
	
	ofstream gfdoutfile;
	gfdoutfile.open(genomic_frequency_distribution_file.c_str());
	if ( ! gfdoutfile )
	{	cerr << "fail to open input file" << genomic_frequency_distribution_file << endl;
	}
	int loop_mark = 1;
	while (1)
	{	
		calculate_posterior_pi( ai_num,  p_i,  new_p_i);

		qfloat total_diff = 0.0;
		for (int i=0; i<ai_num; i++)
		{	total_diff += abs(p_i[i] -  new_p_i[i]);
		}
		if (total_diff <= Total_diff_cutoff)
		{	
			gfdoutfile << "\n#################################################\n";
			gfdoutfile << "Last Round: " << loop_mark << "\n";
			gfdoutfile << "Total_diff: " << total_diff << "\n";
			gfdoutfile << "gfreq\tpost_p_i\n";
			for (int i=0; i<ai_num; i++)
			{
				double out_i = (!Consider_heterozygosity) ? (i+1) : (float(i+1)/2);
				gfdoutfile << out_i << "\t" << new_p_i[i] << endl;
				p_i[i] = new_p_i[i];
			}
			break;
		}
		else
		{
			gfdoutfile << "\n#################################################\n";
			gfdoutfile << "Middle Round: " << loop_mark << "\n";
			gfdoutfile << "Total_diff: " << total_diff << "\n";
			gfdoutfile << "gfreq\tprior_p_i\tpost_p_i\n";
			for (int i=0; i<ai_num; i++)
			{
				double out_i = (!Consider_heterozygosity) ? (i+1) : (float(i+1)/2);
				gfdoutfile << out_i << "\t" << p_i[i] << "\t" << new_p_i[i] << endl;
				p_i[i] = new_p_i[i];
			}
			
		}
		loop_mark ++;
	}
	
	//generate the theoretic coverage depth curve file, based on given c and ai.
	ofstream cddoutfile;
	cddoutfile.open(coverage_depth_distribution_file.c_str());
	if ( ! cddoutfile )
	{	cerr << "fail to open input file" << coverage_depth_distribution_file << endl;
	}
	
	//resources  ai_num  p_i[i]  Rfreq_range Mean_depth
	cddoutfile << "#kmer_coverage_depth" << "\t" << "Kmer_species_ratio" << endl;
	for (int j=0; j<=Rfreq_range; j++)
	{	qfloat p_j = 0.0;
		for (int i=0; i<ai_num; i++)
		{	qfloat c = (!Consider_heterozygosity) ? (i+1)*Mean_depth : (float(i+1)/2)*Mean_depth;
			p_j += p_i[i] * pow(c,j) / exp(c) / JCvec[j];
		}
		cddoutfile << j << "\t" << p_j << endl;
	}

	time_end = clock();
	cerr << "\nAll jobs finishd done\n";
	cerr << "Run time: " << double(time_end - time_start) / CLOCKS_PER_SEC << endl;

}


