#!/usr/bin/perl

=head1 Name

estimate_genome_size.pl   --  estimate genome size and sequencing coverage from P(x) and F(x)

=head1 Description

Read the *freq.stat file generated by kmerfreq as input file, which contains P(x) and F(x) distributions.
Remove low-frequency K-mers caused by sequencing errors.
Find the major peak, consider it was formed by unique Kmers (genomic freq==1).
Adjust the peak to accurate float values from the neighboring two integers. 

Automatically find the lowfreq cutoff.

From the statistic of lowfreq kmers, we can also estimate the sequencing error rate of reads data.

=head1 Version

  Author: Fan Wei, fanw@genomics.org.cn
  Version: 1.0,  Date: 2011-8-12
  Note:

=head1 Usage

  perl estimate_genome_size.pl  <species_frequency_file.stat>
  --verbose   output running progress information to screen  
  --help      output help information to screen  

=head1 Exmple



=cut

use strict;
use Getopt::Long;
use FindBin qw($Bin $Script);
use File::Basename qw(basename dirname); 
use Data::Dumper;
use File::Path;  ## function " mkpath" and "rmtree" deal with directory

##get options from command line into variables and set default values
my ($LowFreq_cutoff, $Verbose,$Help);
GetOptions(
	"verbose"=>\$Verbose,
	"help"=>\$Help
);
die `pod2text $0` if (@ARGV == 0 || $Help);

my $kmerfreq_stat_file = shift;

my %PX;
my %FX;
my @Data;
my $total_px = 0;
my $total_fx = 0;
my $total_lowfreq_px = 0;
my $total_lowfreq_fx = 0;

##load data from input file
open IN, $kmerfreq_stat_file || die "fail open $kmerfreq_stat_file";
while (<IN>) {
	next if(/^\s/ || /^\#/);
	s/^>=//;   ##freq最大边界255的也计算在内
	##print $_;
	my @t = split /\s+/;
	my $freq = $t[0];
	my $px_num = $t[1];
	my $fx_num = $t[4];
	push @Data,[$freq,$px_num,$fx_num];		
}
close IN;

##find the $LowFreq_cutoff at the lowest turning point, 只根据P(x)找出最低的拐点处
my $low_cutoff_freq = $Data[0][0];
my $low_cutoff_num = $Data[0][1];
for (my $i=1; $i<@Data; $i++) {
	if ($Data[$i][1] < $low_cutoff_num) {
		$low_cutoff_num = $Data[$i][1];
		$low_cutoff_freq = $Data[$i][0];
	}else
	{	last;
	}
}
$LowFreq_cutoff = $low_cutoff_freq;
$LowFreq_cutoff = 0 if ($LowFreq_cutoff == 1); ##no cutoff at this case
print  "The automatically calculated lowfreq cutoff is: $LowFreq_cutoff\n";

####################################################################
for (my $i=0; $i<@Data; $i++) {
	my $freq = $Data[$i][0];
	my $px_num = $Data[$i][1];
	my $fx_num = $Data[$i][2];
	
	if ($freq <= $LowFreq_cutoff) {
		$total_lowfreq_px += $px_num;
		$total_lowfreq_fx += $fx_num;
		$px_num = 0;
		$fx_num = 0;
		
	}else{
		$total_px += $px_num;
		$total_fx += $fx_num;
	}
	
	if ($freq < 255) {
		$PX{$freq} = $px_num;
		$FX{$freq} = $fx_num;
	}
}
####################################################################


my $total_nk_species = $total_lowfreq_px + $total_px;
my $total_nk_individuals = $total_lowfreq_fx + $total_fx;
my $lowfreq_rate1 = $total_lowfreq_px / $total_nk_species;
my $lowfreq_rate2 = $total_lowfreq_fx / $total_nk_individuals;

print "\nTotal kmer species:     $total_nk_species\n";
print "Total kmer individuals: $total_nk_individuals\n";
print  "Total kmer species (lowfreq excluded): $total_px\n";
print  "Total kmer individuals(lowfreq excluded): $total_fx\n";


print  "\nNumber of lowfreq Kmer species caused by sequencing errors: $total_lowfreq_px\n";
print "\tRatio in all kmer species: $lowfreq_rate1\n";
print  "Number of lowfreq Kmer individuals caused by sequencing errors: $total_lowfreq_fx\n";
print  "\tRatio in all kmer individuals: $lowfreq_rate2\n";


##find the max rate value in P(x) and F(x)
my $px_max_freq = 0;
my $px_max_num = 0;
my $fx_max_freq = 0;
my $fx_max_num = 0;
foreach my $freq (sort {$a<=>$b} keys %PX) {
	if ($PX{$freq} > $px_max_num) {
		$px_max_freq = $freq;
		$px_max_num = $PX{$freq};
	}
	if ($FX{$freq} > $fx_max_num) {
		$fx_max_freq = $freq;
		$fx_max_num = $FX{$freq};
	}
}


##recalculate the rate after removing low freq kmers
foreach my $freq (sort {$a<=>$b} keys %PX) {
	
	$PX{$freq} = $PX{$freq} / $total_px;
	$FX{$freq} = $FX{$freq} / $total_fx;
}


my $integer_c_fx = $fx_max_freq - 1;
print "\nInteger c by p(x) and f(x): $px_max_freq\t$integer_c_fx\n";

my $px_c = 0;
my $fx_c = 0;
my $mini_rate_cut = 0.0001;

#calculate all c values by all neighboring points, then select enough number to calcualte the average
my $stat_px_points = 0;
my $px_left_border = $px_max_freq - 3;
$px_left_border = 1 if ($px_left_border < 1);
my $px_right_border = $px_max_freq + 2;

for (my $x=$px_left_border; $x<=$px_right_border; $x++){
	if ( $PX{$x}>$mini_rate_cut && $PX{$x+1}> $mini_rate_cut ){
		$stat_px_points ++;
		$px_c += $PX{$x+1} / $PX{$x} * ($x+1);
	}
}
$px_c /= $stat_px_points;

my $stat_fx_points = 0;
my $fx_left_border = $fx_max_freq - 3;
$fx_left_border = 1 if ($fx_left_border < 1);
my $fx_right_border = $fx_max_freq + 2;
for (my $x=$fx_left_border; $x<=$fx_right_border; $x++){
	if ( $FX{$x}>$mini_rate_cut && $FX{$x+1}> $mini_rate_cut ){
		$stat_fx_points ++;
		$fx_c += $FX{$x+1} / $FX{$x} * $x;
	}
}
$fx_c /= $stat_fx_points;

my $av_c = ($px_c + $fx_c) / 2;

print "\nThe estimated float-point expected coverage depth:\n";
print "\tc by P(x): $px_c \t using $stat_px_points points\n";
print "\tc by F(x): $fx_c \t using $stat_fx_points points\n";
print "\tc by P(x) and F(x): $av_c\n";


my $px_G = int($total_fx / $px_c);
my $fx_G = int($total_fx / $fx_c);
my $av_G = int($total_fx / $av_c); 

print "\nThe roughly estimated genome size (nk filtered but not adjusted):\n";
print "\tG by P(x): $px_G\n";
print "\tG by F(x): $fx_G\n";
print "\tG by P(x) and F(x): $av_G\n";


####################################################
################### Sub Routines ###################
####################################################
